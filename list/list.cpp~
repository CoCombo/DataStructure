#include <iostream>

template <typename Object>
class List
{
    private:
	struct Node
	{
	    Object data;
	    Node *prev, *next;

	    Node(const Object & d = Object(), Node *p = nullptr, Node *n = nullptr) : data(d),
										      prev(p),
										      next(n)
	    {}
	};

    public:
	class const_iterator
	{
	    public:
		const_iterator() : current(nullptr) {}

		const Object & operator * () const {return retrive();}
		const_iterator & operator ++ () 
		{
		    current = current->next;
		    return *this;
		}
		const_iterator & operator ++ (int )
		{
		    const_iterator old = *this;
		    ++(*this);
		    return old;
		}
	};
	class iterator : public const_iterator
	{};

    public:
	List()
	{}
	List(const List & rhs)
	{}
       ~List()
        {}
	const List & operator = (const List & rhs)
	{}
	
	iterator       begin()       {return iterator(head->next);}
	const_iterator begin() const {return const_iterator(head->next);}
	iterator       end()         {return iterator(tail);}
	const_iterator end() const   {return const_iterator(tail);}

	int  size()  const           {return theSize;}
	bool empty() const           {return theSize == 0;}

	void clear()
	{
	    while( !empty() )
		pop_front();
	}
	      Object & front()       {return *begin();}
	const Object & front() const {return *begin();}
 	      Object & back()        {return *--end();}
        const Object & back()	     {return *--end();}

	void push_front(const Object & x) {insert(begin(), x);}
	void push_back (const Object & x) {insert(end(), x);}
	void pop_front ()                 {erase(begin());}
	void pop_back  ()                 {erase(end());}

	iterator insert(iterator it, const Object & x)
	{}
	iterator erase (iterator it)
	{}
	iterator erase (iterator start, iterator end)
	{}

	private:
	    int theSize;
	    Node *head, *tail;

	    void init()
	    {}
};
void insert(const T &x, avlNode * &t)
{
    if(t == nullptr)
	t = new avlNode(x, nullptr, nullptr);
    else if(x < t->element)
    {
	insert(x, t->left);
	if( height(x->left) - height(x->right) == 2)
	    if( x < t->left->element)
		rotateLeftChile(t);
	    else
		doubleLeftChild(t);
    }
    else if(x > t->element)
    {
	insert(x, t->right);
	if(height(t->right) - height(t->left) == 2)
	    if(x < t->right->element)
		
    }
}
